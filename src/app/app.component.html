<app-header></app-header>
<h1>Hello {{ title }}</h1>
<!--ðŸ‘‰ here title is in interpolation, it is used to pass our objects, properties or functions or variables from to ts to html for ex see belowðŸ‘‡-->
<p>accessing title = {{ getTitle() }}</p>
<p>accessing object = {{ obj.name }} {{ obj.age }}</p>
<p>accessing array = {{ arr }}</p>
<p>using properties like length on array = {{ arr.length }}</p>
<p>operations inside interpolation ={{ a + b }}</p>

<!-- we can't assign values using interpolation and we can't use window object in interpolation-->

<!--ðŸ‘‰ component :-  -->
<app-user-list></app-user-list>
<h2>Angular Module</h2>
<app-login></app-login>
<app-signup></app-signup>
<button (click)="myEvent('click Event')">Click Event</button>
<br />
<br />
<input type=" text" (keyup)="myEvent('keyup Event')" /> <br />
<br />
<!-- it only counts number of keyPressed but if value to be accessed try following ðŸ‘‡-->
<div id="input"></div>
<input type="text" #inputField (keyup)="myEvent(inputField.value)" />
<!-- we can use keyUp.enter or keyUp.space it will return value when enter and space clicked-->

<br />
<br />

<!-- get input value from input field -->
<input type="text" #inp (keyup)="getVal(inp.value)" />

<div>
  {{ currentVal }}
</div>

<!-- getting value after button click  -->
<input type="text" #box />

<button (click)="getVal(box.value)">get value</button>

<!--ðŸ‘‰ property binding [] it handles dynamic attributes so allows dynamic values or functions & interpolation{{}} it's exclusively for string it doesn't allow assigning value or {{windows.location.href}}-->

<br />
<br />
<input type="text" [disabled]="disabledBox" value="{{ name }}" />
<!--ðŸ‘‰ property binding-->
<!-- or -->
<br />
<br />
<!--ðŸ‘‰ interpolation-->
<input type="text" disabled="{{ disabledBox }}" [value]="name" />
<br />
<br />
<button (click)="enableBox()">enable textbox</button>

<!--ðŸ‘‰ hence clearly we can see that property binding enabled on button click but interpolation doesn't so this dynamic transformation is only with it or we can say property binding alone can handle attribute-->

<!--ðŸ‘‰ conditions in angular -->

<h1 *ngIf="show; else elseBlock">if block</h1>
<ng-template #elseBlock> else block</ng-template>

<div *ngIf="color == 'red'; then redBlock; else otherBlock"></div>
<ng-template #redBlock>
  <div>red block</div>
</ng-template>
<ng-template #otherBlock>
  <div>other block</div>
</ng-template>

<ng-template [ngIf]="color == 'green'">
  <div>green Block</div>
</ng-template>
<ng-template [ngIf]="color == 'yellow'">
  <div>yellow Block</div>
</ng-template>
<ng-template [ngIf]="color == 'violet'">
  <div>violet Block</div>
</ng-template>

<!--ðŸ‘‰ switch case in angular [ngSwitch] -->

<div [ngSwitch]="color">
  <h2 *ngSwitchCase="'red'">red color</h2>
  <h2 *ngSwitchCase="'violet'">violet color</h2>
  <h2 *ngSwitchCase="'green'">green color</h2>
  <h2 *ngSwitchCase="'yellow'">yellow color</h2>
</div>

<h4>for loop in Angular</h4>
<table border="1" style="border: 1px solid">
  <tr>
    <td>Name</td>
    <td>age</td>
    <td>E-mail</td>
  </tr>
  <tr *ngFor="let item of data">
    <td>
      {{ item.name }}
    </td>
    <td>
      {{ item.age }}
    </td>
    <td>
      {{ item.email }}
    </td>
  </tr>
</table>

<br />
<br />
<!--ðŸ‘‰ simple form in angular : go to app module.ts and import formsModule from angular/Forms also add formsModule in import section below there. form must have a id to which (ngForm) will assigned , now add a function to event (ngSubmit)-->
<form #simpleForm="ngForm" (ngSubmit)="getUserValue(simpleForm.value)">
  <!-- argument will pass this form value to function-->
  <input type="text" ngModel name="userName" placeholder="enter name" />
  <br /><br />
  <!--now add ngModel to each field with connects fields to form-->
  <input type="text" ngModel name="age" placeholder="enter age" /><br /><br />
  <input
    type="text"
    ngModel
    name="address"
    placeholder="enter address"
  /><br /><br />
  <button>Get Values</button>
</form>

<!-- make reusable Header and footer component -->

<!--ðŸ‘‰ style binding , use style.any css property enclosed with square bracket and assign values enclosed with both double and single quotes  -->
<h3 [style.color]="'red'">header by style binding</h3>
<!--ðŸ‘‰ dynamic style, define a variable with value in ts file and user that variable here as value it will pass the provided value in ts  ðŸ‘‡  -->
<h3 [style.color]="color">header by dynamic style</h3>
<!--here single quote is not required-->
<button (click)="changeCol()">change color</button>

<br />
<br />
<!-- conditional style ðŸ‘‡ -->
<h3 [style.color]="err ? 'red' : 'green'">header by conditional style</h3>

<!--ðŸ‘‰ to add bootStrap in angular project we have to run ðŸ‘‰ ng add @ng-bootstrap/ng-bootstrap in command line-->

<p *ngFor="let alert of alerts">
  <ngb-alert [type]="alert.type" (closed)="close(alert)">{{
    alert.message
  }}</ngb-alert>
</p>
<p>
  <button type="button" class="btn btn-primary" (click)="reset()">Reset</button>
</p>

<!--ðŸ‘‰ material ui in angular  run command ðŸ‘‰ ng add @angular/material in terminal -->
<!-- now for ex we can use a material button , import in app module as import {MatButtonModule} from '@angular/material/button' also register it in imports in the same file , now here or anywhere in html file use button-->
<button mat-button>Mat button</button>
<mat-slider min="1" max="100" step="1" value="5"></mat-slider>

<!--ðŸ‘‰ pass data from parent to child : make a users component make it child of app component pass data from app component to child component and display there -->
<h3>pass data from parent to child component</h3>
<!--ðŸ‘‰ first declare a variable in  parent's TS file then in child comp's selector (where it is being used) write a token(any name by which you want to access) in property bind way and assign it the variable declared in parent's ts asðŸ‘‡ then go to child comps ts include input in import list from @angular/core and then write @input() yourTokenNameWhatever before constructor, then go to child comp's html and use {{tokenName or tokenName.field(in case of obj)}}  -->
<!--<app-child-comp [yourTokenNameWhatever as inherit2 below ðŸ‘‡]="parentToChild"></app-child-comp> -->
<!--while fetching simle variable -->
<app-child-comp [inherit2]="parentChild_Obj"></app-child-comp>
<!--while fetching object-->

<!--ðŸ‘‰ make a component reusable -->
<div *ngFor="let data of parentToChild_Arr">
  <app-child-arr-comp [hero]="data"></app-child-arr-comp>
</div>

<!--ðŸ‘‰ send data from child to parent using eventEmitter(it calls parent's func from child) :- make a child component, lets declare a function in parent's TS now bind it with child selector with yourTokenNameWhatever as (yourTokenNameWhatever)='funcName($event)' in parent's html or whereEver this child comp's selector is being used,  now go to child's ts and import output and eventEmitter from @angular/core , then write @output()  yourTokenNameWhatever :EventEmitter<dataType> =new EventEmitter() before constructor , and in the same file's ngOnInit{this.yourTokenNameWhatever.emit("whateverYourArgs")} note this emit func is auto generated when we use eventEmitter -->
<h3>sending data to parent from child</h3>
<app-child-to-parent
  (childToParentData)="childToParent($event)"
></app-child-to-parent>

<br />

<h3>{{ childToPar.name }}</h3>
<h3>{{ childToPar.age }}</h3>

<!--ðŸ‘‰ Pips (|) in Angular : used to change the format of string, date currency or anything else in our desired format , it's used as {{ourVariable | funToFormat }} as ex ðŸ‘‡-->
<h4>{{ title | uppercase }}</h4>
<!-- ðŸ‘‰now title which is in lowerCase   in ts is converted to upperCase here due to pipe and func-->
<div>{{ today | date : "fullDate" }}</div>
<!--lets declare a today var in ts and initialize it with date.Now(); now here if we don't use pipe with date it will just show in MilliSecond so we have to use pipe with date or pipe with date:'fullDate'-->
<!-- we can use all str arr or any JS fun with pip as exp below ðŸ‘‡ we are using slice with str var from TS -->
<div>{{ str }}</div>
<!-- will show full StringWithPips as declared but with slice:2:5 it will slice 2 index from start  and till 5 index -->
<div>{{ str | slice : 1 : 9 }}</div>
<!-- pips with currency  -->
<div>{{ val | currency : "CAD" }}</div>
<!--here CAD is for canadian dolor like wise we can use USD for american -->

<!--ðŸ‘‰ routing : if you didn't choose routing opt while project creation and wish now to add , run command ðŸ‘‰ ng generate module app-routing --flat --module=app  -->
<!--ðŸ‘‰ but if a routing.modules.ts file is available in folders means routing is already selected yes so go to fileName.routing.modules.ts file and in const:routs{
  create a obj as path:'asYouWish', component: componetNameToRedirect
  
    and import this same component at the top as import comp from folderName
    now repeat this same process to route another component  
    now go to the page where we have to route our comps and add as many  anchor tags as comps you have to route but instead of href attribute we have to use routerLink='pathWhichGivenInRoutingModule' then use <router-outlet></router-outlet> there for ExðŸ‘‡
}-->

<h3>admin pages</h3>
<br />
<a routerLink="admin/login">admin-login</a>
<br />
<br />
<a routerLink="admin/list">admin-list</a>
<br />
<br />
<h3>visitors pages</h3>
<br />
<a routerLink="visitors/login">login</a>
<br />
<br />
<a routerLink="visitors/list">list</a>
<br />
<br />
<a routerLink="routingDemo">Routing Demo</a> <br />
<br />
<a routerLink="routingAdmin">Routing Admin</a>
<br />
<br />

<a routerLink="routing">Routing Recap</a>
<br />
<br />

<p>lazy loading</p>
<ul>
  <li><a routerLink="lazyloading/lazyload/lazyComp">first lazy comp</a></li>
  <li><a routerLink="lazyloading/lazyload/lazy2comp">second lazy comp</a></li>
</ul>
<br />
<br />
<p>lazy loading user</p>
<ul>
  <li>
    <a routerLink="userLazyload/userInLazy/list">user list in lazyLoading</a>
  </li>
  <li>
    <a routerLink="userLazyload/userInLazy/login">user login in lazyLoading</a>
  </li>
</ul>
<br />
<br />
<p>route revision or early loading</p>
<ul>
  <li><a routerLink="route/comp1">route comp1</a></li>
  <li><a routerLink="route/comp2">route comp2</a></li>
</ul>
<!-- ðŸ‘‰ how to create 404 page : create a not found comp and add it to routing module provide ** in path there (it's known as wildccard means it will appear when user request for a page which doesn't exists)-->

<a routerLink="about">About</a>
<br />
<br />
<a routerLink="contactUs">contactUs</a>
<!--it will call pageNotFound since contactUs page is unavailable -->
<br />
<br />

<a routerLink="routing">Routing Recap</a>
<br />
<br />
<router-outlet></router-outlet>

<!--ðŸ‘‰ custom directives in angular :directives are used to manipulate in DOM ex ngFor ngIf switchCase    
custom directives are used to reflect our desired changes on group of elements (on which it is used) 
run command to create custom directives ðŸ‘‰ ng g directive yourDirectiveName 
then go to its TS file and add ElementRef in import list from @angular/core  
now in export's constructor block create an instance of elementRef with any name 
as constructor(private el:ElementRef){
  now here  we can access nativeElement property of elementRef through its obj el now add style.anyCssPropery="value"
for use we have selector in same ts file , add this sector on any element as <p yourCustomDirSelector>your content</p> changes will reflect there 
} -->
<p appCustomDirective>style by custom directive</p>

<!-- ðŸ‘‰ services in angular : services in angular used to share data with more than one comp , services are neither comp dependent nor module dependent they are fully independent we can use anywhere
run command to create ðŸ‘‰ ng g service yourServiceName 
go to our service.ts file let create a func name getData (){
  return {
name:'anil',
age:30,
id:10
  }
}

import it in ts file of comp where you want to use as import {yourServiceName} from './folderPath'
and create an instance of this serviceCom in same ts 's constructor as private userDAta : UserDataServiceService{console.warn(this.userDAta.getData());}

-->
<h4>{{ nameFrmServices }}</h4>

<!-- API calling in angular -->

<!--ðŸ‘‰ for api call in angular we need service where api is called , so first create a service by ng g service serviceName now go to its ts file and import {httpClient} from @angular/common/http  now go to constructor create an injectable instance with private access modifier as constructor (private anyName:httpClient){} now create a func for api call
  getData(){let url = "apiUrl";return this.anyNameInConstForHttpClient.get(url);} for api call , now go to app module .ts and import httpClientModule from  @angular/common/http,also
  add httpClientModule into import 
  now go to comp ts where we want to fetch data from api 
  import serviceName ./serviceFolderPath
  create an instance of this service in constructor there and add this.instanceName.funcInServiceTsForApiCall().subscribe(data=>{console.log(data)})
}-->

<!-- show data received from api in tabular form -->

<h4>data from API</h4>
<table border="1" style="margin: 20px 0 20px 40px">
  <tbody>
    <tr>
      <th>Id</th>
      <th>Title</th>
      <th>completed</th>
    </tr>
    <tr *ngFor="let item of apiDATA">
      <td>{{ item.id }}</td>
      <td>{{ item.title }}</td>
      <td>{{ item.completed }}</td>
    </tr>
  </tbody>
</table>

<!--ðŸ‘‰ model : model define ds and validations it's part of ts  all we have to do is define an interface in ts or services as interface anyName {
  name:string,
  id:number,
  indian:true,
  address:any
}for the data which we want to use in our func  remember to import this as import interfaceName from path, where we will use func to return interface type data  -->

<!--ðŸ‘‰ module recap : ng g m moduleName :=> now create a component within it as ng g c module/compName, now go to the ts file of component where it's to be used and import and include in imports its handle and path
now go to app.routing module.ts and import components (from path,)  which you want to add as routing, now declare routes for the same comps as  const routes:Route=[{path:'login',component:loginComponent}]
-->
<!-- <a routerLink="routing"></a> -->
<!-- <app-routing></app-routing> -->
<!-- <router-outlet></router-outlet> -->
<!--ðŸ‘‰  routing module : create a routing module using ng g m moduleName --routing; now create components in this routing module , go to the module routing ts and import comps and create path for them , now go to the app.module.ts and import this route module there and also register in imports list

ðŸ‘‰ grouped routing : let say we have same login in user and admin so it's confusing which route is open , here group routing comes in role which provides routing name with its module name as user/login admin/login ðŸ‘‡
ng g m visitor --routing

all processes as like as simple routing but diff in their routing.modules.ts file 
where in routes  we have to declare  path:'admin' , children :[{
path:'login', component : 'loginComName'},
{
path:'list', component : 'listComName'}]

ðŸ‘‰ Lazy loading : It applies on routes,  in normal loading all the routes load initially which results in minimal speed , with lazy loading only routes needed are loaded so speed increases.

 make a module (ng g m moduleName --routing) with two components make routing and load comps using lazy loading ðŸ‘‡ 
declare their routs in routing MODULE
now go to app.routing and declare lazy loading as
{
    path: 'lazyload',
    loadChildren: () =>
      import('./lazyloading/lazyloading.module').then(
        (mod) => mod.LazyloadingModule
      ),
  },
now call them by path before router-outlet  see aboveðŸ‘†


ðŸ‘‰lazy loading component :(load component on click or when need) if components are not called on lazy loading all will be called initially which makes speed slower, so we use lazy loading to call components,  first of all import viewContainerRef and componentFactoryResolver from angular, now create private instance of them in constructor
 as private viewConainer :ViewContainerRef,
    private componentFactory :ComponentFactoryResolver,

    view containerRef create dynamic space for our component, and componentFactoryResolver converts everything into a component
let say we have two components to be called in lazy loading, so now go to html page call the components on two buttons click by a click function, these functions will be async like ðŸ‘‡
 async loadComp2() {
    this.viewConainer.clear();       ------- to clear 
    const { Callinlazy2Component } = await import(
      './callinlazy2/callinlazy2.component'
    );
    this.viewConainer.createComponent(
      this.componentFactory.resolveComponentFactory(Callinlazy2Component)
    );
  }
-->
<p>lazy loading component</p>
<button (click)="loadComp1()">call comp1 in lazy loading mode</button>
<button (click)="loadComp2()">call comp2 in lazy loading mode</button>

<!-- 

ðŸ‘‰angular form : reactive form (control data in ts ) and template driven form(all controls in html page only) 

data flowðŸ‘‡
form >.ts file > service > apiCall > server

1.) template driven form :- basic and simple form mostly written in html 

*)steps to createðŸ‘‡

go to app.module.ts import form module form @angular/forms and register it as well

now go to app.html create
<form #userForm="ngForm" (ngSubmit)="onSubmit(userForm.value)"> here ngForm is directive assigned to form id userForm and userForm's value is being passed as userForm.value 
  <input type="text" name="email" ngModel/><br><br>  ngModel binds fields to form and name is must in template driven form
  <input type="password" name="password" ngModel/><br><br>
  <button type="submit">login</button><br>
</form>

imp: to add validators in template driven forms add a name and ngModel is must
also assign ngModel to the id of field let say it's #email1 so #email1=ngModel
now add required keyword as property -->
<br />
<br />
<p>template driven form ðŸ‘‡</p>

<div class="col-sm-6">
  <form #userForm="ngForm" (ngSubmit)="onSubmit(userForm.value)">
    <div class="mb-3">
      <label for="exampleInputEmail1" class="form-label">Email address</label>
      <input
        type="email"
        class="form-control"
        ngModel
        name="email1"
        required
        id="exampleInputEmail1"
        aria-describedby="emailHelp"
        #email1="ngModel"
      />
      <span class="red-error" *ngIf="email1!.invalid && email1!.touched"
        >field is required</span
      >
    </div>
    <div class="mb-3">
      <label for="exampleInputPassword1" class="form-label">Password</label>
      <input
        type="password"
        name="pass"
        ngModel
        class="form-control"
        id="exampleInputPassword1"
        pass="ngModel"
        required
        #password1="ngModel"
      />
      <span class="red-error" *ngIf="password1.invalid && password1.touched"
        >field is required</span
      >
    </div>

    <button type="submit" class="btn btn-primary">Submit</button>
  </form>
</div>
<br />
<br />

<!-- 
  ðŸ‘‰ add bootstrap in angular form first add bootstrap
  run command ðŸ‘‰ng add @ng-bootstrap/schematics 
  now go to bootstrap webpage and just add  needed classes as above ðŸ‘†

  ðŸ‘‰ Reactive form : go to app module .ts import reactive forms module from @angular/core   now either create your own form or go to bootstrap webpage and copy form code and paste here to customize 
  now go app component.ts file import FormControl,FormGroup from @angular/forms
  on html page  define form attribute as [formGroup]='anyName' in form tag
now in ts file export section define this form group func as 
loginForm = new formGroup({
  pass form fields names defined (note each field of form must  formControlName='anyName')
for ex ðŸ‘‡
 loginForm = new FormGroup(
    { email: new FormControl(''),
     pass: new FormControl('') }
  );

  now for adding validator to our form fields go to import validator from @angular/forms  and just add it in ts parameters of formGroups as 
  loginForm = new FormGroup(
    { email: new FormControl('', Validators.required),
     pass: new FormControl('', Validators.required) }
  );
for invalid fields add red border by inserting invalid class by inspection asðŸ‘‡

input.ng-invalid/valid{border:1px solid color}
imp: form group for reactive forms and formControl name for each fields is imp in reactive forms
for err msg on invalid field valid let's create a get func as
get anyFieldName (){return this.anyFormName.get('anyFieldName')}
now in html create an err msg as <span *ngIf="anyFieldName-invalid && email-touch">Email is required</span>
 -->
<p>reactive form ðŸ‘‡</p>
<div class="col-sm-6">
  <form [formGroup]="loginForm">
    <div class="mb-3">
      <label for="exampleInputEmail1" class="form-label">Email address</label>
      <input
        type="email"
        class="form-control"
        formControlName="email"
        placeholder="email"
        [ngStyle]="{
          border: email?.invalid && email?.touched ? '1px solid red' : ''
        }"
      />
      <span class="red-error" *ngIf="email!.invalid && email!.touched"
        >Email is required</span
      >
    </div>
    <div class="mb-3">
      <label for="exampleInputPassword1" class="form-label">Password</label>
      <input type="password" class="form-control" formControlName="pass" />
      <span class="red-error" *ngIf="password!.invalid && password!.touched"
        >Password is required</span
      >
    </div>

    <button type="submit" class="btn btn-primary">Submit</button>
  </form>
</div>
<br />
<br />
<!-- 

ðŸ‘‰ Prefilled form (template driven) : import formModules form @angular/forms in module.ts

go to ts define a object of anyName fill it with desired prefilled values need to forms 
add an id to form and assign it ngForm directive now add fields with unique name , 
object's key defined in ts with prefilled values must be bind with each  ngModel to every field


 -->

<p>Prefilled form</p>
<form #prefilled="ngForm">
  <input
    type="text"
    name="prefilledEmail"
    [ngModel]="prefilledValues.email"
  /><br /><br />
  <input
    type="password"
    name="prefilledPassword"
    [ngModel]="prefilledValues.pass"
  /><br /><br />
  <input
    type="text"
    name="prefilledAdd"
    [ngModel]="prefilledValues.add"
  /><br /><br />
  <input
    type="text"
    name="prefilledMob"
    [ngModel]="prefilledValues.mob"
  /><br /><br />
  <button type="submit">save</button>
</form>

<!-- 
ðŸ‘‰ prefilled form (reactive form ): import formsModule in app module.ts from angular/forms
in html create a form and provide it  a form group since form group is must in reactive forms and add bind a function to ngSubmit 
now go to component.ts file import formGroup, formControl and validator from angular form
 
now add formControlName to each filled with unique values 
go to ts assign formGroup's value as new formGroup and pass fields formControlName's value as new formControl
-->

<form [formGroup]="preFilledReactive" (ngSubmit)="collectData()">
  <input
    type="text"
    formControlName="preReactiveEmail"
  /><br /><br />
  <input
    type="password"
    formControlName="preReactivePass"
  /><br /><br />
  <button type="submit">Login</button>
</form>
<app-footer></app-footer>
